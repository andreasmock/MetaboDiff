<!DOCTYPE html>
<meta charset="utf-8">
<title>HotNet2 Subnetworks</title>
<link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/css/bootstrap.min.css">
<link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/s/dt/dt-1.10.10/datatables.min.css"/>
<style>
	body{
		font-family:"Helvetica","Arial";
		padding:10px;
	}
	div.container{
		background:"#F6F6F6";
	}
	abbr{
		font-weight:bold;
		color:rgb(36,64,144);
		border:1px solid rgb(36,64,144);
		cursor:help;
		font-size:80%;
		padding:0px 2px 0px 2px;
		float:right;
		margin-left:30px;
	}
	div#figures hr{
		clear:both;
		margin-top:30px;
		border:0;
		border-bottom:1px dashed #777777;
	}
	div#figures div.network{
		width:300px;
		float:left;
	}
	div#figures div.m2{
		width:550px;
		float:right;
	}
</style>
<body>
<div class="container">
	<h1>HotNet2 Results</h1>
	<hr/>
	<div class="col-lg-12 row">
		<div id="instructions" class="col-lg-6">
			<h3>Instructions</h3>
			This page shows the results of a HotNet2 run. Select the parameters &delta; and <i>k</i>
			on the right to view the subnetworks identified by HotNet2, and their statistical significance.
			We include for each subnetwork:
			<ul>
				<li>
					<i>Network view</i> (left). Protein interactions among each subnetwork identified by HotNet2.
					You can toggle the interaction networks shown by clicking them in the legend,
					and you can reposition the nodes in the subnetwork for a better view by dragging/dropping them.
				</li>
				<li>
					<i>Aberrations view</i> (right). Aberrations (SNVs or CNAs) in the genes/proteins identified by HotNet2.
					<em>This view is only visible if you created the heat file used by HotNet2 from mutation data</em>.
				</li>
			</ul>
			We also list all genes input to HotNet2 with their heat scores, and mark those reported by HotNet2 in some subnetwork.
			<br/><br/>
		</div>
		<div id="filters" class="col-lg-6">
			<h3>Parameters</h3>
			<table class="table table-hover">
				<tr>
					<th><label>Minimum edge weight &delta;</label></th>
					<td>
						<select class='form-control' id="deltas"></select>
					</td>
					<td>
						<abbr title="Select one of the deltas automatically chosen by HotNet2. HotNet2 reports a collection of subnetworks and their significance for each automatically chosen delta.">?</abbr>
					</td>
				</tr>
				<tr>
					<th>Minimum subnetwork size <i>k</i></th>
					<td class='text-center'>
						<input type="range" id="k" min="2" value="2" max="10" step="1" />
						<span id="k">2</span>
					</td>
					<td>
						<abbr title="Hide subnetworks of size less than k.">?</abbr>
					</td>
				</tr>
			</table>
		</div>
	</div>
	<div id="genes-by-heat" class="row col-lg-12">
		<div class="panel panel-default">
			<div class="panel-heading" role="button" data-toggle="collapse" href="#heatTableWrapper" aria-expanded="false" aria-controls="heatTableWrapper">
				Table of input heat scores
				<span style="float:right">(click to toggle)</span>
			</div>
			<div id="heatTableWrapper" class="panel-collapse collapse">
				<div class="panel-body">
					<table class="table" id="heatTable">
						<thead><tr style="background:#d3d3d3"><th>Gene</th><th>Heat</th><th>Found by HotNet2?</th></thead>
						<tbody></tbody>
					</table>
				</div>
			</div>
		</div>
	</div>
	<div id="subnetworks" class="row col-lg-12">
		<div class="panel panel-default">
			<div class="panel-heading" role="button" data-toggle="collapse" href="#subnetworkFigures" aria-expanded="true" aria-controls="subnetworkFigures">
				Subnetworks identified by HotNet2
				<span style="float:right">(click to toggle)</span>
			</div>
			<div class="panel-body panel-collapse collapse in" id="subnetworkFigures">
				<div class="row">
					<div class="col-lg-4 text-left" id="params"></div>
					<div class="col-lg-4 text-center" id="download"><a title="Download subnetworks."></a></div>
					<div class="col-lg-4 text-right" id="stats"><span id="observed"></span>, <span id="expected"></span>, <span id="pval"></span></div>
				<hr/>
				<div id="figures"></div>
			</div>
	</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.9/d3.js" type="text/javascript"></script>
<script src="https://code.jquery.com/jquery-2.1.4.min.js" type="text/javascript"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.5/js/bootstrap.min.js" type="text/javascript"></script>
<script src="https://cdn.datatables.net/s/dt/dt-1.10.10/datatables.min.js" type="text/javascript"></script>
<script>
var heatFormat = d3.format(".3r");

// Add the subnetworks
d3.json('subnetworks.json', function(json) {
	// Populate the table of genes by heat
	var geneToHeat = json.geneToHeat,
			predictions = json.predictions,
			predicted = {};

	var geneByHeat = Object.keys(geneToHeat).sort(function(a, b){
		return d3.descending(geneToHeat[a], geneToHeat[b]);
	});
	geneByHeat.forEach(function(g){ predicted[g] = false; })
	predictions.forEach(function(g){ predicted[g] = true; })

	var heatTbl = d3.select('div#genes-by-heat table tbody');
	var heatRows = heatTbl.selectAll('.heat-row')
				 .data(geneByHeat).enter()
				 .append('tr');

	 heatRows.append('td').text(function(d){ return d; });
	 heatRows.append('td').text(function(d){ return geneToHeat[d]; });
	 heatRows.append('td').text(function(d){ return predicted[d]; });

	 $('div#genes-by-heat table').dataTable();

	// Populate the delta select and the ks slider
	var deltaSelect = d3.select("div#filters select"),
			numDeltas = json.deltas.length;
	deltaSelect.selectAll(".delta")
		.data(json.deltas.sort(function(a, b){ return d3.ascending(+a, +b); })).enter()
		.append("option")
		.attr("selected", function(d, i){ return i === numDeltas-1 ? "selected" : ""; })
		.attr("value", function(d){ return d; })
		.text(function(d){ return d; })

	var kSlider = d3.select("div#filters input")
		.attr("min", d3.min(json.ks))
		.attr("max", d3.max(json.ks));

	// Add listeners to the deltaSelect and kSlider
	deltaSelect.on("change", drawSubnetworks);
	kSlider.on("change", filterSubnetworks);

	var delta = json.deltas[numDeltas-1],
		fig = d3.select("#figures");

	function drawSubnetworks(){
		// Retrieve the current delta
		if (d3.select(this).node().value){
			delta = d3.select(this).node().value;
		}

		// Remove the old subnetworks
		fig.selectAll("div").remove();

		// Create an object that contains any changes to the default styles
		var styling = {
			fontColor: '#34495E',
			heatLegendWidth: 300,
			netLegendWidth: 90,
			width: 300
		}

		// Add each subnetwork as an SVG wrapped in a div
		json.subnetworks[delta].forEach(function(d, i){
			var g = fig.append("div")
						.attr("class", "subnetwork k" + d.nodes.length);

			g.append("div")
				.datum(d)
				.attr("class", "network")
				.call(
					subnetwork({style: styling})
						.addNetworkLegend()
						.addGradientLegend()
		  		)
		  	// Only draw the mutation matrix if there is data
		  	if (json.mutation_matrices[delta]){
                                // Identify the samples mutated in this subnetwork
		  		var mutSamples = filterSamples(d.nodes.map(function(g){ return g.name; }), json.mutation_matrices[delta][i], json.sampleToTypes);

                                // Create the customized mutation matrix function, including
                                // a sample legend if there are more than one cancer type
                                var m2 = mutation_matrix({style: {width: 550}}).addCoverage();
                                if (Object.keys(json.typeToSamples).length > 1)
                                    m2 = m2.addSampleLegend();

			  	g.append("div")
			  		.attr("class", "m2")
			  		.style("margin-bottom", "30px")
			  		.datum(
			  			{M: json.mutation_matrices[delta][i],
			  			 samples: mutSamples,
			  			 sampleToTypes: json.sampleToTypes,
			  			 typeToSamples: json.typeToSamples}
			  		)
			  		.call(m2)

		  	}

		  	g.append("hr");
		});
		filterSubnetworks();
	} // end drawSubnetworks

	var stats = d3.select("div#stats");
	function filterSubnetworks(){
		// Get the current value of k from the slider
		var k = kSlider.node().value;

		// Update the title to reflect the new subnetworks and significance
		d3.select("div#params").html("&delta; = " + delta + ", k = " + k);

		// Update the slider value, and update the signficance
		d3.select("span#k").text(k);
		stats.select("span#pval").html("P=" + json.stats[delta][k].pval);
		stats.select("span#expected").html("Expected: " + json.stats[delta][k].expected);
		stats.select("span#observed").html("Observed: " + json.stats[delta][k].observed);

		// Show subnetworks of size at least k, hide the rest
		d3.selectAll("div.subnetwork").style("display", "inline");
		d3.range(d3.min(json.ks), k).forEach(function(k){
			d3.selectAll(".k" + k).style("display", "none");
		});

		// Show subnetworks of size at least k, hide the rest
                var filteredSubnets = json.subnetworks[delta].filter(function(d){ return d.nodes.length >= k; })
                     .map(function(d){ return d.nodes.map(function(n){ return n.name; }).join("\t"); })
                     .join("\n");
                d3.select("div#download a")
                  .attr("download", "subnetworks-d" + delta + "-k" + k + ".txt")
                  .attr("href", window.URL.createObjectURL(new Blob([filteredSubnets], {type: 'text/plain'})))
                  .text("Download text file of subnetworks");
	}

	function filterSamples(genes, M, samples){
		var sampleToMutated = {};
		genes.forEach(function(g){
			Object.keys(M[g]).forEach(function(s){
				sampleToMutated[s] = true;
			});
		});
		return Object.keys(sampleToMutated).map(function(s){ return {name: s, _id: s}; });
	}

	// Draw the subnetworks, starting with the first delta
	drawSubnetworks();

});

// gd3 subnetwork function
function subnetwork(params) {
  var params = params || {},
	  style  = params.style || {},
	  colorSchemes = style.colorSchemes || {};

  var cold = style.cold || 'rgb(102, 178, 255)',
	  edgeWidth = style.edgeWidth || 1.5,
	  fontColor = style.fontColor || '#333',
	  fontFamily = style.fontFamily || '"Helvetica","Arial"',
	  fontSize = style.fontSize || 10,
	  heatLegendHeight = style.heatLegendHeight || 30,
	  heatLegendWidth = style.heatLegendWidth ||  100,
	  height = style.height || 200,
	  hot = style.hot || 'rgb(255, 51, 51)',
	  margins = style.margins || {bottom: 0, left: 0, right: 0, top: 0},
	  netLegendBox = style.netLegendBox || 15,
	  netLegendWidth = style.netLegendWidth || 200,
	  nodeRadius = style.nodeRadius || 10,
	  transitionTime = style.transitionTime || 500,
	  width = style.width || 350;

  var showNetworkLegend = false,
	  showGradientLegend = false;

  function chart(selection) {
	selection.each(function(data) {
	  //////////////////////////////////////////////////////////////////////////
	  // General setup
	  var edges = data.edges,
		  nodes = data.nodes;

	  // Select the svg element, if it exists.
	  var fig = d3.select(this)
		  .selectAll('svg')
		  .data([data])
		  .enter()
			.append('svg');

	  fig.attr('id', 'figure')
		  .attr('height', height + margins.top + margins.bottom)
		  .attr('width', width)
		  .style('font-family', fontFamily)
		  .style('font-size', fontSize);

	  // Create the color scale
	  var heatRange = nodes.map(function(n){ return n.heat; }),
		  color = d3.scale.linear()
			  .domain([d3.min(heatRange), d3.max(heatRange)])
			  .range([cold, hot])
			  .nice();

	  // Set up the force directed graph
	  var force = d3.layout.force()
		  .charge(-400)
		  .linkDistance(40)
		  .size([width, height]);

	  // This drag function fixes nodes in place once they are dragged
	  var drag = force.drag().on('dragstart', function(d) {
		d.fixed = true;
		d3.select(this).select('circle').style('stroke-opacity', 0);
	  });

	  // Set up scales
	  var x = d3.scale.linear().range([0, width]),
		  y = d3.scale.linear().range([0, height]);

	  var links = loadLinks(edges, nodes);

	  force.nodes(nodes)
		  .links(links)
		  .start();

	  // Determine which networks are in the data
	  var networks = [];
	  for (var i = 0; i < links.length; i++) {
		for (var j = 0; j < links[i].networks.length; j++) {
		  if (networks.indexOf(links[i].networks[j]) == -1) {
			networks.push(links[i].networks[j]);
		  }
		}
	  }

	  var numNets = networks.length,
		  netLegendHeight = numNets * 10;

	  // Make sure each network has a color
	  if (colorSchemes.network == undefined) {
		var colors = d3.scale.category20();
		colorSchemes.network = {};
		for (var i = 0; i < networks.length; i++) {
		  colorSchemes.network[networks[i]] = colors(i);
		}
	  }

	  // Draw the edges
	  var link = fig.selectAll('.link')
		  .data(links);

	  var linkInNetwork = {},
		  activeNetworks = {};

	  for (var i = 0; i < networks.length; i++) {
		var net = networks[i],
			netName = net.split('.').join('');
			netColor = colorSchemes.network[networks[i]];
			activeNetworks[net] = true;

		var inNet = fig.selectAll('.' + netName)
				.data(links.filter(function (link) {
				  return link.networks && link.networks.indexOf(net) != -1;
				}))
				.enter()
				.append('line')
				  .classed(netName, true)
				  .style('stroke-width', edgeWidth)
				  .style('stroke', netColor);

			linkInNetwork[net] = inNet;
	  }

	  // Draw the nodes
	  // Keep the circles and text in the same group for better dragging
	  var circle = fig.append('svg:g')
		  .selectAll('node')
		  .data(nodes)
		  .enter()
		  .append('svg:g')
			.style('cursor', 'move')
			.call(force.drag)
			.on('dblclick', function(d) {
			  d.fixed = d.fixed ? false : true;
			  d3.select(this).select('circle').style('stroke-opacity', 1);
			});

	  circle.append('circle')
		  .attr('r', nodeRadius)
		  .attr('fill', function(d) { return color(d.heat); })
		  .style('stroke-width', 1.5)
		  .style('stroke', '#333');

	  circle.append('text')
		  .attr('x', nodeRadius)
		  .attr('y', '.31em')
		  .style('fill', fontColor)
		  .style('font-size', fontSize)
		  .text(function(d) { return d.name; });

	  // Make sure nodes don't go outside the borders of the SVG
	  force.on('tick', function() {
		circle.attr('transform', function(d) {
		  d.x = Math.max(nodeRadius, Math.min(width - nodeRadius, d.x));
		  d.y = Math.max(nodeRadius, Math.min(height - nodeRadius, d.y));
		  return 'translate(' + d.x + ',' + d.y + ')';
		});

		networks.forEach(function(net, i) {
		  var offset = edgeWidth * (i = numNets / 2);
		  linkInNetwork[net]
			  .attr('x1', function(d) { return d.source.x + offset; })
			  .attr('y1', function(d) { return d.source.y + offset; })
			  .attr('x2', function(d) { return d.target.x + offset; })
			  .attr('y2', function(d) { return d.target.y + offset; });
		});
	  }); // end force

	  //////////////////////////////////////////////////////////////////////////
	  // DRAW LEGENDS
	  function renderNetworkLegend() {
		var netLegend = fig.selectAll(".net-group")
			.data(networks).enter()
			.append("g")
				.style("font-size", 12)
				.on("click", function(n){
					var active = activeNetworks[n];
					activeNetworks[n] = !active;
					linkInNetwork[n].transition().duration(transitionTime)
						.style("stroke-opacity", active ? 0 : 1);

					d3.select(this).transition().duration(transitionTime)
						.style("stroke-opacity", active ? 0.5 : 1)
						.style("fill-opacity", active ? 0.5 : 1);
				});

		netLegend.append("line")
			.attr("x1", 0)
			.attr("x2", netLegendBox)
			.style("stroke-width", edgeWidth)
			.style("stroke", function(n){ return colorSchemes.network[n]; });

		netLegend.append("text")
			.attr("x", 8 + netLegendBox)
			.attr("y", 3)
			.text(function(n){ return n; });

		netLegend.attr("transform", function(d, i){
			return "translate(" + (width-d3.select(this).node().getBBox().width) + "," + ((i+1)*netLegendBox) + ")";
		})

	  } // end renderNetworkLegend()


	  function renderGradientLegend() {
		var heatLegend = selection.append('div')
			.attr('id', 'subnetwork-legend')
			.style('width', heatLegendWidth + 'px');

		var gradient = heatLegend.append('svg')
			.attr('width', heatLegendWidth)
			.attr('height', heatLegendHeight);

		// Create a unique ID for the heat gradient
		var gradientID = 'heat_gradient' + Date.now();
		gradient.append('svg:defs')
			.append('svg:linearGradient')
			  .attr('x1', '0%')
			  .attr('y1', '0%')
			  .attr('x2', '100%')
			  .attr('y2', '0%')
			  .attr('id', gradientID)
			  .call(function (gradient) {
				gradient.append('svg:stop')
				  .attr('offset', '0%')
				  .attr('style', 'stop-color:' + cold + ';stop-opacity:1');
				gradient.append('svg:stop')
				  .attr('offset', '100%')
				  .attr('style', 'stop-color:' + hot + ';stop-opacity:1');
			  });

		gradient.append('rect')
			.attr('width', heatLegendWidth)
			.attr('height', heatLegendHeight)
			.style('fill', 'url(#' + gradientID + ')');

		var labels = heatLegend.append('div')
			.style('clear', 'both');
		var format = d3.format("g");

		heatLegend.append('span')
		  .style('float', 'left')
		  .text(heatFormat(d3.min(heatRange)));

		heatLegend.append('span')
		  .style('float', 'right')
		  .text(heatFormat(d3.max(heatRange)));
	  } // end renderGradientLegend()


	  if(showNetworkLegend) {
		renderNetworkLegend();
	  }
	  if(showGradientLegend) {
		renderGradientLegend();
	  }


	  //////////////////////////////////////////////////////////////////////////
	  // UTILITY FUNCTIONS
	  // Returns list of links between a given set of nodes and an edge list
	  function loadLinks(edges, nodes) {
		var links = [];

		for (var i = 0; i < nodes.length; i++) {
		  var u = nodes[i].name;
		  for(var j = 0; j < nodes.length; j++) {
			var v = nodes[j].name;
			for (var k = 0; k < edges.length; k++) {
			  var src = edges[k].source,
				  tgt = edges[k].target;
			  if ( (u == src && v == tgt) || (u == tgt && v == src) ) {
				links.push({
				  'source': nodes[i],
				  'target': nodes[j],
				  'weight': edges[k].weight,
				  'networks': edges[k].networks
				})
			  }
			}
		  }
		}

		return links;
	  } // end loadLinks()
	});
  } // end chart()


  chart.addNetworkLegend = function () {
	showNetworkLegend = true;
	return chart;
  }

  chart.addGradientLegend = function () {
	showGradientLegend = true;
	return chart;
  }



  return chart;
}

// gd3 mutation matrix function
function mutation_matrix(params) {
  var params = params || {},
      style  = params.style || {},
      colorSchemes = style.colorSchemes || {};

  var animationSpeed = style.animationSpeed || 300,
      bgColor = style.bgColor || '#F6F6F6',
      blockColorMedium = style.blockColorMedium || '#95A5A6',
      blockColorStrongest = style.blockColorStrongest || '#2C3E50',
      boxMargin = style.boxMargin || 5, // assumes uniform margins on all sides
      colorSampleTypes = style.colorSampleTypes || true,
      coocurringColor = style.coocurringColor || 'orange',
      exclusiveColor = style.exclusiveColor || 'blue',
      continuousScaleColors = style.continuousScaleColors || [['#fcc5c0','#49006a'], ['#ffffff', '#000000']],
      fullWidth = style.width || 500,
      fullHeight = style.height || 300,
      geneHeight = style.geneHeight || 20,
      labelHeight = style.labelHeight || 75,
      labelWidth = style.labelWidth || 100,
      minBoxWidth = style.minBoxWidth || 20,
      mutationLegendHeight = style.mutationLegendHeight || 30,
      sampleStroke = style.sampleStroke || 1,
      sampleAnnotationSpacer = style.sampleAnnotationSpacer || 5;

  var styleLookup = {
    'bgColor': bgColor,
    'blockColorMedium': blockColorMedium,
    'blockColorStrongest': blockColorStrongest,
    'boxMargin': boxMargin,
    'colorSampleTypes': colorSampleTypes,
    'coocurringColor': coocurringColor,
    'exclusiveColor': exclusiveColor,
    'fullWidth': fullWidth,
    'fullHeight': fullHeight,
    'geneHeight': geneHeight,
    'labelHeight': labelHeight,
    'labelWidth': labelWidth,
    'minBoxWidth': minBoxWidth,
    'sampleStroke': sampleStroke
  };

  var sampleTypeToColor = colorSchemes.sampleType || {};

  // Define the set of mutation types we are considering, and by default show them all
  var mutationTypes = params.mutationTypes || ["snv", "inactive_snv", "del", "amp", "fus", "other"],
    mutationTypeToInclude = {},
    mutationTypesPresent = {};

  mutationTypes.forEach(function(d){
    mutationTypeToInclude[d] = true;
    mutationTypesPresent[d] = false;
  });

  // Define globals to be used when filtering the mutation matrix by sample type
  var sampleTypeToInclude = {},
      updateMutationMatrix,
      ticks,
      annotate,
      tip,
      onclickFunction,
      numContCats = 0;

  // These variables determine what extras to show in the chart
  var showCoverage = false,
      showSampleLegend = false,
      showMutationLegend = false,
      showSortingMenu = false,
      showTooltips = false,
      showDuplicates = false,
      addOnClick = false,
      annotationsIncludeNoData = false;

  // Sample annotation information
  var annotationData,
      showSampleAnnotations = false;

  function chart(selection) {
    selection.each(function(data) {
      //////////////////////////////////////////////////////////////////////////
      // General setup
      var M = data.M || {},
          sampleToTypes = data.sampleToTypes || {},
          sampleTypes = data.sampleTypes || [],
          typeToSamples = data.typeToSamples || {},
          samples = data.samples;

      var genes = Object.keys(M),
          numGenes = genes.length;

      // If no samples were provided, construct them all with equal z_index
      if (!samples){
        samples = Object.keys(sampleToTypes).map(function(sample){
          return { _id: sample, name: sample, z_index: 1 }
        });
      }

      // Assign each sample a sample name id (snid), depending on whether
      // or not we're collapsing/showing duplicates
      samples.forEach(function(s){ s.snid = showDuplicates ? s._id : s.name });

      // Identify the unique samples by snid
      var SNIDs = {};
      samples.sort(function(a, b){ return d3.ascending(a.z_index, b. z_index); });
      samples.forEach(function(s){
        if (!SNIDs[s.snid]) SNIDs[s.snid] =  s;
      });

      var uniqueSamples = [];
      Object.keys(SNIDs).forEach(function(snid){ uniqueSamples.push( SNIDs[snid] ); });
      var numMutatedSamples = uniqueSamples.length;

      // Collect all unique types for all samples
      for(var i = 0; i < samples.length; i++) {
        if(sampleTypes.indexOf(sampleToTypes[samples[i]._id]) == -1) {
          sampleTypes.push(sampleToTypes[samples[i]._id]);
        }
      }
      sampleTypes.sort();
      sampleTypes.forEach(function(t){ sampleTypeToInclude[t] = true; });

      // Then determine whether the data includes multiple datasets
      var multiDataset = (sampleTypes.length > 1) && colorSampleTypes,
          datasetLegendWidth = multiDataset ? 100 : 0,
          datasetTypeLegendHeight = multiDataset ? (sampleTypes.length+1)*15 : 0,
          width = fullWidth - (showSampleLegend ? datasetLegendWidth : 0),
          height = genes.length * geneHeight + boxMargin,
          rectHeight = height,
          tickWidth,
          samplesPerCol;

      // Count the total number of samples across all datasets
      if (showDuplicates){
        var numSamples = sampleTypes.reduce(function(total, t){ return total + typeToSamples[t].length; }, 0);
      }
      else{
        var allSampleNames = {};
        sampleTypes.forEach(function(t){
          typeToSamples[t].forEach(function(s){ allSampleNames[s] = true; });
        })
        var numSamples = Object.keys(allSampleNames).length;

      }

      // Assign colors for each type if no type coloration information exists
      var sampleTypesWithColors = sampleTypes.reduce(function(total, d){
        return sampleTypeToColor[d] ? total + 1 : total;
      }, 0);
      if (sampleTypesWithColors != sampleTypes.length) {
        var colors = d3.scale.category20();
        for (var i = 0; i < sampleTypes.length; i++) {
          if (!sampleTypeToColor[sampleTypes[i]])
            sampleTypeToColor[sampleTypes[i]] = colors(i);
        }
      }

      // Update the height and sample annotation colors if necessary
      var categorySets = {};
      if (showSampleAnnotations) {
          var categories = annotationData.categories || [],
              sampleAs = annotationData.sampleToAnnotations || {},
              aColors = annotationData.annotationToColor || {};

          // Adjust height if sampleAnnotations
          var firstAnnotation = Object.keys(annotationData.sampleToAnnotations)[0];
              numAnnTypes = annotationData.sampleToAnnotations[firstAnnotation].length;
          rectHeight = height;
          height = height + numAnnTypes*(geneHeight + sampleAnnotationSpacer);

          // Assign colors for each annotation
          var annotationColors = {};

          categories.forEach(function(c, i){
            var isNumeric = true,
                data = [],
                values = [];

            Object.keys(sampleAs).forEach(function(s){
                // Determine if the value is numeric
                var ty = typeof(sampleAs[s][i]),
                    val = sampleAs[s][i];
                isNumeric = isNumeric && (val == null || val == "" || ty === 'number');

                // Ignore blank values
                if (!(val == "" || val == null)){
                  data.push(val);
                  if (isNumeric) values.push(sampleAs[s][i]);
                } else {
                  annotationsIncludeNoData = true;
                }

              });

            // Doesn't matter if there are no numeric values, d3.max and d3.min
            // can handle it and will return null
            var d = {min: d3.min(values), max: d3.max(values) };

            // Assign colors to all annotations
            var scale;

            if(isNumeric) {
              var contColors = continuousScaleColors[numContCats];

              scale = d3.scale.linear()
                .domain([d.min, d.max])
                .range(contColors)
                .interpolate(d3.interpolateLab);
              scale.type = "linear";

              // Increase the count of categories with continuous data
              numContCats += 1;
              if (numContCats >= continuousScaleColors.length){
                numContCats = 0;
              }
            } else {
              // Assign a unique color to each unique annotation value
              var uniqItems = data.filter(function(item, pos) {
                return data.indexOf(item) == pos;
              });
              var uniqColors = uniqItems.map(function(d){
                if (aColors[c] && aColors[c][d]) return aColors[c][d];
                else return '#' + Math.floor(Math.random()*16777215).toString(16); // uniform at random color
              });

              categorySets[c] = uniqItems.map(function(d){ return {cat: c, ann: d}});

              // Use an ordinal scale to map each item to a color
              scale = d3.scale.ordinal()
                .domain(uniqItems)
                .range(uniqColors);
              scale.type = "ordinal";
            }
            annotationColors[c] = scale;
        });
      }

      // Compute height of SVG
      var svgHeight = height + labelHeight;
      if (showSampleAnnotations)
        svgHeight += categories.length*geneHeight/2 + 3*sampleAnnotationSpacer;

      // Map each gene to the samples they're mutated in
      var geneToSamples = {};
      for (i = 0; i < genes.length; i++) {
        geneToSamples[genes[i]] = Object.keys(M[genes[i]]);
      }

      // Sort genes by their coverage, and make a map of each gene to its row index
      var geneToIndex = {};
      var sortedGenes = genes.sort(function(g1, g2){
        return geneToSamples[g1].length < geneToSamples[g2].length ? 1 : -1;
      });
      d3.range(0, genes.length).forEach(function(i){ geneToIndex[sortedGenes[i]] = i; })

      //////////////////////////////////////////////////////////////////////////
      //////////////////////////////////////////////////////////////////////////
      // Parse and sort mutation data

      // Sorting order for mutation types
      var mutTypeOrder = { fus: 0, inactive_snv: 1, snv: 2, amp: 3, del: 4, other: 5 };

      // Constants that correspond to the different sorting functions
      var SAMPLE_TYPE = 0,
          SAMPLE_NAME = 1,
          MUTATION_TYPE = 2,
          EXCLUSIVITY = 3,
          GENE_FREQ = 4,
          // Short descriptions of the different sorting functions
          sortFnName = { };
          sortFnName[EXCLUSIVITY] = 'Exclusivity';
          sortFnName[GENE_FREQ] = 'Gene frequency';
          sortFnName[MUTATION_TYPE] = 'Mutation type';
          sortFnName[SAMPLE_NAME] = 'Sample name';
          sortFnName[SAMPLE_TYPE] = 'Sample type';


      // Parse the mutation data into a simple, sample-centric dictionary
      // sample -> { name, genes, dataset, cooccurring }
      // where genes is a list of mutations
      // gene   -> { amp, del, inactive_snv, snv, g, dataset, cooccurring }
      function createMutationMatrixData( M, geneToSamples, genes, samples, sampleToTypes ){
        // Define the data structures we'll populate while iterating through the mutation matrix
        var mutatedSamples = {},
            sampleToMutations = {};

        sampleToExclusivity = {};
        geneToFreq = {};
        sampleToGeneIndex = {};
        geneToSampleMutationType = {};

        genes.forEach(function(g){
          geneToFreq[g] = 0;
          geneToSampleMutationType[g] = {};
        });

        samples.forEach(function(s){
          sampleToGeneIndex[s.snid] = Number.POSITIVE_INFINITY;
        })

        // Iterate through the mutation matrix to summarize the mutation data
        function recordMutation(sample, muts){
          if (!(sample.snid in sampleToMutations)) sampleToMutations[sample.snid] = muts;
          else{
            var mutGenes = sampleToMutations[sample.snid].genes.map(function(d){ return d.gene; });
            muts.genes.forEach(function(d){
              if (mutGenes.indexOf(d.gene) == -1){
                sampleToMutations[sample.snid].genes.push( d );
              }
            });
          }
        }

        samples.forEach(function(s){
          var muts = { _id: s._id, name: s.name, snid: s.snid, genes: [], dataset: sampleToTypes[s._id] };

          // Add an empty mutation if the sample type is not included
          if (!sampleTypeToInclude[sampleToTypes[s._id]]){
            muts.cooccurring = false;
            recordMutation(s, muts);
            return;
          }

          // Record all mutated genes for the given sample
          var genesMutInSample = [];
          genes.forEach(function(g){
            // Record all mutation types that the current gene has in the
            // current sample
            var mutTys = [];
            if (geneToSamples[g].indexOf( s._id ) != -1){
              mutated = false;
              // Find all the mutation types in this gene in this sample
              var allMutTys = M[g][s._id].filter(function(t){ return mutationTypeToInclude[t]; })
                .sort(function(ty1, ty2){ return mutTypeOrder[ty1] < mutTypeOrder[ty2] ? 1 : -1; });

                allMutTys.forEach(function(t){
                    muts.genes.push( {gene: g, dataset: sampleToTypes[s._id], ty: t, sample: s, mutTys: allMutTys } );
                    mutated = true;
                    mutTys.push( t );
                    mutationTypesPresent[t] = true;
                    if (genesMutInSample.indexOf(g) == -1)
                      genesMutInSample.push( g );
                  });

              if (mutated){
                geneToFreq[g] += 1;
                mutatedSamples[s.snid] = true;
                sampleToGeneIndex[s.snid] = d3.min([sampleToGeneIndex[s.snid], geneToIndex[g]]);

                // Store the minimum mutation type index for each gene and sample to make
                // sorting as simple as possible later
                var minMutTy = d3.min(mutTys.map(function(m){ return mutTypeOrder[m]; }));
                geneToSampleMutationType[g][s.snid] = d3.min([minMutTy, geneToSampleMutationType[g][s.snid]]);
              }
            }
          });

          // Determine if the mutations in the given sample are co-occurring
          muts.cooccurring = sampleToExclusivity[s.snid] = genesMutInSample.length > 1;
          muts.genes.forEach(function(d) {
            d.cooccurring = muts.cooccurring;
          });
          recordMutation(s, muts);
        });

        // Flatten the sample mutations
        var sampleMutations = [];
        Object.keys(sampleToMutations).forEach(function(s){
          sampleMutations.push( sampleToMutations[s] );
        });

        // Determine the coverage of the gene set
        var coverage = Object.keys(mutatedSamples).length;

        return {  sampleMutations: sampleMutations, coverage: coverage, geneToFreq: geneToFreq,
                  sampleToExclusivity: sampleToExclusivity, sampleToGeneIndex: sampleToGeneIndex,
                  geneToSampleMutationType: geneToSampleMutationType
                };
      } // end createMutationMatrixData()


      // Sort sample *indices*
      function sortSamples(sortOrder, sortedGenes, sampleToGeneIndex, sampleToExclusivity) {
        // Comparison operators for pairs of samples
        function geneFrequencySort(s1, s2) {
          // Sort by the first gene in which the sample is mutated
          return d3.ascending(sampleToGeneIndex[s1.snid], sampleToGeneIndex[s2.snid]);
        }

        function exclusivitySort(s1, s2) {
          // Sort by the exclusivity of mutations in the samples
          return d3.ascending(sampleToExclusivity[s1.snid], sampleToExclusivity[s2.snid]);
        }

        function mutationTypeSort(s1, s2) {
          // Sort by the type of mutation
          var ind1 = sampleToGeneIndex[s1.snid],
              ind2 = sampleToGeneIndex[s2.snid];

          if (ind1 < sortedGenes.length)
            var mut_type1 = geneToSampleMutationType[sortedGenes[ind1]][s1.snid];
          if (ind2 < sortedGenes.length)
            var mut_type2 = geneToSampleMutationType[sortedGenes[ind2]][s2.snid];

          return mut_type1 > mut_type2 ? 1 : mut_type1 == mut_type2 ? 0 : -1;
        }

        function sampleNameSort(s1, s2) {
          // Sort by sample name
          return d3.ascending(s1.name, s2.name);
        }

        function sampleTypeSort(s1, s2) {
          // Sort by sample type
          return d3.ascending(sampleToTypes[s1._id], sampleToTypes[s2._id]);
        }

        // Create a map of the sort constants to the functions they represent
        var sortFns = {};
        sortFns[EXCLUSIVITY] = exclusivitySort;
        sortFns[GENE_FREQ]   = geneFrequencySort;
        sortFns[MUTATION_TYPE] = mutationTypeSort;
        sortFns[SAMPLE_NAME] = sampleNameSort;
        sortFns[SAMPLE_TYPE]   = sampleTypeSort;

        return d3.range(0, numMutatedSamples).sort(function(i, j){
            var s1 = uniqueSamples[i],
                s2 = uniqueSamples[j],
                result;

            for (k = 0; k < sortOrder.length; k++){
                result =  sortFns[sortOrder[k]](s1, s2);
                if (result != 0) return result;
            }

            return result;
        });
      } // End sortSamples(sortOrder);

      function updateMutationData(){
        // Load the mutation data, taking into account the restrictions on mutation- and sample-types
        mutationData = createMutationMatrixData(M, geneToSamples, genes, samples, sampleToTypes);
        sampleMutations = mutationData.sampleMutations;
        sampleToGeneIndex = mutationData.sampleToGeneIndex;
        sampleToExclusivity = mutationData.sampleToExclusivity;
        geneToFreq = mutationData.geneToFreq;
        coverage = mutationData.coverage;
        geneToSampleMutationType = mutationData.geneToSampleMutationType;

        // Sort the samples, then create a mapping of samples to the location index of
        // the visualization on which they should be drawn
        var sortedSampleIndices = sortSamples(sampleSortOrder, sortedGenes, sampleToGeneIndex, sampleToExclusivity);
        sampleToIndex = {};
        for ( var i = 0; i < numMutatedSamples; i++ ) {
          sampleToIndex[uniqueSamples[sortedSampleIndices[i]].snid] = i;
        }
      }

      // Parse the mutation data and sort the samples using a default sort order
      var sampleSortOrder = [GENE_FREQ, SAMPLE_TYPE, EXCLUSIVITY, MUTATION_TYPE, SAMPLE_NAME];
      var sampleMutations, sampleToGeneIndex, sampleToExclusivity,
          sampleToIndex, geneToFreq, geneToSampleMutationType, coverage;
      updateMutationData();

      //////////////////////////////////////////////////////////////////////////
      //////////////////////////////////////////////////////////////////////////
      // Construct the SVG

      // Select the svg element, if it exists.
      var svg = d3.select(this)
          .selectAll('svg')
          .data([data])
          .enter()
            .append('svg');

      // Offset the image placement using the margins
      var fig = svg.append("g")
          .attr('transform', 'translate(' + boxMargin + ',' + boxMargin + ')');

      // Add the row (gene) labels
      var geneLabelGroups = fig.selectAll('.geneLabels')
          .data(genes)
          .enter()
          .append('svg:g')
            .attr('class', 'geneLabel')
            .attr('transform', function(d, i) {
              return 'translate(0,'+(geneToIndex[d]*geneHeight)+')';
            });

      var geneLabels = geneLabelGroups.append('text')
          .attr('class', 'gene-name')
          .attr('font-size', 14)
          .attr('text-anchor', 'end')
          .text(function(g) { return g+ ' (' + geneToFreq[g] + ')'; });

      var maxLabelWidth = 0;
      geneLabels.each(function() {
        var tmpWidth = d3.select(this).node().getBBox().width;
        maxLabelWidth = maxLabelWidth > tmpWidth ? maxLabelWidth : tmpWidth;
      });

      labelWidth = maxLabelWidth;

      geneLabels.attr('transform', function(d, i) {
              return 'translate('+labelWidth+','+(geneHeight - boxMargin)+')';
          });

      // Scales for the height/width of rows/columns
      var x = d3.scale.linear()
          .domain([0, numMutatedSamples])
          .range([labelWidth + boxMargin, width - boxMargin]);

      svg.attr('id', 'mutation-matrix')
          .attr('width', width)
          .attr('height', svgHeight)
          .attr('xmlns', 'http://www.w3.org/2000/svg');

      // Append the rectangle that will serve as the background of the ticks
      var bgRect = fig.append('rect')
          .style('fill', bgColor)
          .attr('width', width - labelWidth - boxMargin)
          .attr('height', rectHeight)
          .attr('transform', 'translate(' + (labelWidth + boxMargin) + ',0)');

      // Add groups that include sample labels
      var sampleYAdjust = geneHeight*genes.length + 3*sampleAnnotationSpacer;
      if (showSampleAnnotations)
        sampleYAdjust += 2*sampleAnnotationSpacer + (categories.length * (geneHeight/2 + sampleAnnotationSpacer));

      var sampleLabelsG = fig.append("svg:g")

      var sampleLabels = sampleLabelsG.selectAll(".sample-label")
          .data(sampleMutations).enter()
          .append("text")
          .attr('fill', blockColorMedium)
          .attr('text-anchor', 'start')
          .style("font-size", "10px")
          .text(function(s) { return s.name; });

      var sampleLabelsLabel = sampleLabelsG.append("text")
        .attr("y", sampleYAdjust + 10)
        .attr("text-anchor", "end")
        .attr("x", labelWidth)
        .style("font-size", "12px")
        .text("Sample IDs");

      // Add groups that include each sample's mutations
      var g = fig.append('svg:g').attr('id', 'mutation-matrix');
      var matrix = g.selectAll('.sample')
          .data(sampleMutations)
          .enter()
          .append('svg:g')
            .attr('class', 'sample')
            .attr('id', function(s) { return s.name; });

      x = d3.scale.linear()
          .domain([0, numMutatedSamples])
          .range([labelWidth + boxMargin, width - boxMargin]);


      bgRect.attr('transform', 'translate('+labelWidth+','+ '0)');

      // Add horizontal lines to separate rows (genes)
      var rowLines = fig.selectAll('.horizontal-line')
          .data(genes)
          .enter()
          .append('line')
            .attr('x2', width - labelWidth)
            .attr('transform', function(d, i) {
              var moveX = labelWidth + boxMargin,
                  moveY = i*geneHeight;
              return 'translate(' + moveX + ',' + moveY +')';
            })
            .style('stroke', '#fff');

      // Helper functions for determining the type of mutation
      function isDel(t){ return t == "del" ;}
      function isAmp(t){ return t == "amp" ;}
      function isSnv(t){ return t == "snv" ;}
      function isOther(t){ return t == "other" ;}
      function isInactivating(t){ return t == "inactive_snv" ;}
      function isFus(t){ return t == "fus" ;}

      // Add columns holding each sample and its mutations
      var cols = matrix.append('g').attr('transform', 'translate(0,0)');

      // Add the mutations in groups
      var mutations = cols.selectAll('.muts')
          .data(function(d){ return d.genes})
          .enter()
          .append("g");

      ticks = mutations.append('rect')
            .attr('class', function(d){ return "tick " + d.ty; })
            .attr('fill', function(d) {
              if (!multiDataset) {
                if (isFus(d.ty) && isSnv(d.ty)) {
                  return bgColor;
                } else {
                  return d.cooccurring ? coocurringColor : exclusiveColor;
                }
              } else {
                if (isFus(d.ty) && isSnv(d.ty)) {
                  return bgColor;
                } else {
                  return sampleTypeToColor[d.dataset];
                }
              }
            });

      // Add stripes to inactivating mutations
      var inactivating = mutations.append('rect')
            .filter(function(d) { return isInactivating(d.ty); })
            .attr('class', 'inactivating')
            .attr('width', tickWidth)
            .attr('height', geneHeight/4)
            .style('fill', blockColorStrongest);

      // Add triangle for fusion/rearrangement/splice site
      var fus = mutations.append('svg:path')
            .filter(function(d) { return isFus(d.ty); })
            .attr('class', 'fusion')
            .attr('d', d3.svg.symbol().type('triangle-up').size(8))
            .style('stroke-opacity', 0)
            .style('fill', function(d) {
              if (multiDataset) {
                return sampleTypeToColor[d.dataset];
              } else {
                return d.cooccurring ? coocurringColor : exclusiveColor;
              }
            });

        // Initialize sample annotations data if desired
        var sampleAnnotations;
        if(showSampleAnnotations) {
          var yAdjust = geneHeight*genes.length + 3*sampleAnnotationSpacer;

          sampleAnnotations = matrix.append('g')
              .attr('transform', 'translate(0,' + yAdjust + ')');

          // Append row labels
          var sampleAnnotationLabelsGroup = fig.append('g');
          var sampleAnnotationLabels = sampleAnnotationLabelsGroup.selectAll('text')
                .data(annotationData.categories)
                .enter()
                .append('text')
                  .attr('text-anchor', 'end')
                  .attr('width', geneLabels.node().getBBox().width)
                  .attr('x', labelWidth)
                  .attr('y', function(d,i) { return yAdjust + i*(sampleAnnotationSpacer+geneHeight/2) + geneHeight/2;})
                  .style('font-size', 12) // TODO: need a way not to hard-code this
                  .text(function(d){return d});

          // Append each annotation to the matrix
          sampleAnnotations.each(function(d) {
              var name = d.name,
                  thisEl = d3.select(this);

              if(sampleAs[name]) {
                thisEl.selectAll('rect')
                    .data(sampleAs[name])
                    .enter()
                    .append('rect')
                        .attr('height', geneHeight/2)
                        .attr('x', 0)
                        .attr('y', function(d,i){ return (sampleAnnotationSpacer+geneHeight/2)*i; })
                        .style('fill', function(d,i) {
                          if (d == "" || d == null) return "#333";
                          else return annotationColors[categories[i]](d);
                        })
                    .append("title").text(function(d){
                      if (d == "" || d == null) return name + ": No data"
                      else return name + ": " + d;
                    });
              }
            });

          sampleAnnotationLabels.each(function() {
          var tmpWidth = d3.select(this).node().getBBox().width;
            maxLabelWidth = maxLabelWidth > tmpWidth ? maxLabelWidth : tmpWidth;
          });

          labelWidth = maxLabelWidth;

          x = d3.scale.linear()
            .domain([0, numMutatedSamples])
            .range([labelWidth + boxMargin, width - boxMargin]);

          rowLines.attr('transform', function(d, i) {
              var moveX = labelWidth + boxMargin,
                  moveY = i*geneHeight;
              return 'translate(' + moveX + ',' + moveY +')';
            });

          bgRect.attr('transform', 'translate('+labelWidth+','+ '0)');
          sampleAnnotationLabels.attr('x', labelWidth);
          sampleLabelsLabel.attr('x', labelWidth);
          geneLabels.attr('transform', function(d, i) {
                  return 'translate('+labelWidth+','+(geneHeight - boxMargin)+')';
              });
        }// end draw Sample annotations

      var other = mutations.append('line')
        .filter(function(d){ return isOther(d.ty); })
        .attr('class', 'other')
        .attr('x1', function(d){ return 0; })
        .attr('y1', function(d){ return 0; })
        .attr('y2', function(d){ return geneHeight; })
        .style('stroke', '#000')
        .style('stroke-width', 2);

      /////////////////////////////////////////////////////////////////////////
      // Add annotations to the mutations (if required)
      if (showTooltips){
        // Initialize the tooltip
        tip = d3.tip()
          .attr('class', 'd3-tip')
          .offset([-10, 0])
          .html(annotate);

        svg.call(tip);

        // Mutation matrix tool tips are stored in a div classed m2-tooltip
        // On mouse over the tooltip:
        //  * the tooltip is shown
        //  * the div.less-info is hidden
        //  * the div.more-info is shown

        var tooltipEl = "div.gd3-tooltip";

        // Toggle the more- and less-info divs appropriately
        var toggleInfo = function (more, less){
          d3.select(tooltipEl + " div.more-info").style("display", more ? "inline" : "none" );
          d3.select(tooltipEl + " div.less-info").style("display", less ? "inline" : "none") ;
        }

        // Define the bevhaior for closing out (X-ing out) the tooltip
        var closeout = function(d){
          tip.hide(d);
          d3.select(this).on("mouseout", function(){ tip.hide(d); });
          toggleInfo(false, true);
        }

        // Define the behavior for showing the tooltip
        var activate = function(d){
          tip.show(d);
          d3.select(tooltipEl).insert("span", ":first-child")
            .style("cursor", "pointer")
            .style("float", "right")
            .attr("class", "x")
            .on("click", closeout)
            .text("X");
        }

        // Activate and toggle the .more- and .less-info divs
        var activateAndToggle = function(d){
          activate(d);
          toggleInfo(true, false);
        }

        // Bind the tooltip behavior
        mutations.on("mouseover", activate)
                 .on("mouseout", tip.hide)
                 .on("click", function(d){
                    activateAndToggle(d);
                    d3.select(this).on("mouseout", activateAndToggle);

                    // Add the user defined clickability
                    if (addOnClick){ onclickFunction(d, i); }
                 });
      }
      else if ( addOnClick ){ mutations.on("click", onclickFunction); }



      // Zoom behavior
      var zoom = d3.behavior.zoom()
          .x(x)
          .scaleExtent([1, Math.round( minBoxWidth * numMutatedSamples / width)])
          .on('zoom', function() { renderMutationMatrix(); });
      svg.call(zoom);

      //////////////////////////////////////////////////////////////////////////
      //////////////////////////////////////////////////////////////////////////
      // Render function for mutation matrix
      // Main function for moving sample names and ticks into place depending on
      //    zoom level
      function renderMutationMatrix() {
        // Functions for determining which mutations and samples to fade in/out
        function inViewPort(snid){
          return x(sampleToIndex[snid]) >= (labelWidth + boxMargin) && x(sampleToIndex[snid]) <= width;
        }

        function isActive(d){
          return inViewPort(d.sample.snid) && mutationTypeToInclude[d.ty] && sampleTypeToInclude[sampleToTypes[d.sample._id]];
        }

        // Identify ticks/samples that are visible form the viewport
        var activeCols = cols.filter(function(d){ return inViewPort(d.snid); })
          .style('fill-opacity', 1)
          .style('stroke-opacity', 1);

        // Fade columns out of the viewport but still active
        cols.filter(function(d){ return !inViewPort(d.snid); })
          .style('fill-opacity', 0.25)
          .style('stroke-opacity', 1);

        // Fade out sample labels appropriately
        sampleLabels.style("opacity", function(d){
          var visible = inViewPort(d.snid),
              active = sampleTypeToInclude[sampleToTypes[d._id]];
          return visible && active ? 1 : 0.25;
        });

        // Completely fade out ticks that are out of the viewport or inactive
        mutations.style("opacity", 0).style("stroke-opacity", 0);
        mutations.filter(function(d){ return isActive(d) })
          .style("opacity", 1).style("stroke-opacity", 1);
        mutations.filter(function(d){ return !isActive(d) && mutationTypeToInclude[d.ty] && sampleTypeToInclude[sampleToTypes[d.sample._id]] })
          .style("opacity", 0.25).style("stroke-opacity", 0.25);

        // Recalculate tick width based on the number of samples in the viewport
        var numVisible = activeCols[0].length,
            printWidth = width - labelWidth - boxMargin;

        samplesPerCol = 1;

        while(samplesPerCol * printWidth / numVisible < 4) {
          samplesPerCol += 1;
        }

        tickWidth = printWidth / numVisible;

        // Move the small ticks of the inactivating group to the right place
        inactivating.attr('width', tickWidth)
            .attr('y', function(d, i) {
              var partialHeight = geneToIndex[d.gene] ? geneToIndex[d.gene] : 0;
              return  (partialHeight + 0.375) * geneHeight;
            });

        // Move the small ticks of the fusion group to the right place
        fus.attr('transform', function(d) {
              var translateX = tickWidth/2,
                  translateY = ((geneToIndex[d.gene] ? geneToIndex[d.gene]: 0)) *
                      geneHeight + geneHeight/2,
                  scale = tickWidth/6;

              var translateStr = 'translate('+translateX+','+translateY+')',
                  rotateStr = 'rotate(90)',
                  scaleStr = 'scale('+scale+')';

              return translateStr + ',' + rotateStr + ',' + scaleStr;
            });

        // Move the 'other' lines to the right place
        other.attr('x2', tickWidth)
          .attr('transform', function(d) {
              var translateY = ((geneToIndex[d.gene] ? geneToIndex[d.gene]: 0)) * geneHeight;
              return 'translate(0,' + translateY + ')';

            });

        // Move the matrix
        matrix.attr('transform', function(d) { return 'translate(' + x(sampleToIndex[d.snid]) + ')'; });
        sampleLabels.attr('transform', function(d) {
          return 'translate(' + x(sampleToIndex[d.snid]) + ',' + sampleYAdjust + ')rotate(90)';
        });

        // Update the text size of the sample names depending on the zoom level
        // represented by `tickWidth`
        matrix.selectAll('text')
            .style('font-size', (tickWidth < 8) ? tickWidth : 8)
            .attr('transform', 'translate(' + (tickWidth/2) + ',' + (labelHeight+i*geneHeight)
                + '), rotate(-90)');

        // Move the ticks to the right places
        ticks.attr('width', tickWidth)
            .attr('height', function(d) {
              return isDel(d.ty) || isAmp(d.ty) ? geneHeight/2 : geneHeight
            })
            .attr('y', function(d, i) {
              var index = geneToIndex[d.gene] ? geneToIndex[d.gene] : 0,
                  delOffset = isDel(d.ty) ? geneHeight / 2 : 0;
              return d.y = index * geneHeight + delOffset;
            });

        // Update the sample width legend
        d3.select('rect#sampleWidthRect')
            .attr('width', samplesPerCol * tickWidth - (2*sampleStroke));

        var sampleStr = samplesPerCol == 1 ? 'sample' : 'samples';
        d3.select('text#sampleWidthText')
            .attr("transform", "translate(" + (tickWidth + 5) + ",0)")
            .text(samplesPerCol + ' ' + sampleStr);


        if (showSampleAnnotations) {
          var sampleAs = annotationData.sampleToAnnotations,
              aColors = annotationData.annotationToColor || {};
          sampleAnnotations.each(function(d) {
            var name = d.name,
                thisEl = d3.select(this),
                visible = inViewPort(d.snid),
                active =  sampleTypeToInclude[sampleToTypes[d._id]];

            thisEl.selectAll('rect')
              .attr('width', tickWidth)
              .style("opacity", visible && active ? 1 : active ? 0.1 : 0);
          });
        }

        // Add sample lines
        // First remove the old sample lines
        svg.selectAll('.vert-line').remove();

        // Compute the indices of samples that are visible, and filter the
        //    indices by the number of samples per column
        var activeIndices = matrix.data().map(function(d, i) {return i; })
            .filter(function(i) {
              return x(i) >= (labelWidth + boxMargin) && x(i) <= width
            })
            .filter(function(d, i) {
              return i % samplesPerCol == 0;
            });

        svg.selectAll('.vert-line')
          .data(activeIndices)
          .enter()
          .append('line')
            .attr('x1', -height)
            .attr('y1', boxMargin)
            .attr('y2', boxMargin)
            .attr('class', 'vert-line')
            .attr('transform', function(i) {
              return 'translate(' + x(i) + ',' + boxMargin +'), rotate(-90)';
            })
            .style('stroke', '#fff')
            .style('stroke-width', sampleStroke);

      } // end renderMutationMatrix();

      var legendMarginLeft = 10, coverageContainer;
      function generateCoverageStr(){
        return ((coverage*100. / numSamples).toFixed(2)) + "% (" + coverage + "/" + numSamples + ")"
      }

      function renderCoverage() {
        var coverage_span = selection.append('div')
            .style('float', 'right')
            .style("font-size", "14px")
            .style('margin-right', (showSampleLegend ? datasetLegendWidth - legendMarginLeft : 0) + 'px');

        coverage_span.append('b').text('Coverage: ');
        coverageContainer = coverage_span.append('span').text(generateCoverageStr());
      }

      // Functions for making the legends interactive
      updateMutationMatrix = function (){
          updateMutationData();
          geneLabels.text(function(g) { return g+ ' (' + geneToFreq[g] + ')'; });
          coverageContainer.text(generateCoverageStr());
          renderMutationMatrix();
      }

      // Function for toggling sampleTypes
      function toggleSampleType(el, ty){
        var active = sampleTypeToInclude[ty],
        opacity = active ? 0.5 : 1;

        d3.select(el).selectAll("*")
        .style("fill-opacity", opacity)
        .style("stroke-opacity", opacity);

        sampleTypeToInclude[ty] = !active;
        updateMutationMatrix();
      }

      function renderSampleLegend() {
          // There is no sample legend if the mutation matirx isn't multiDataset
          if (!multiDataset) return;

          // Dataset legend
          var legendBoxSize = 15,
              datasetLegend = selection.insert('svg', 'svg')
                  .attr('id', 'sample-type-legend')
                  .attr('width', datasetLegendWidth - legendMarginLeft)
                  .attr('height', datasetTypeLegendHeight)
                  .style('float', 'right')
                  .style('margin-left', legendMarginLeft)
                  .style('margin-bottom', 10)
                  .style('font-size', 10);

          datasetLegend.append('text')
              .attr('x', 2)
              .attr('y', 10)
              .style('font-weight', 'bold')
              .text('Sample Types');

          var datasetTypes = datasetLegend.selectAll('.dataset-legend')
              .data(sampleTypes)
              .enter()
              .append('g')
                .attr('transform', function(d, i) { return 'translate(2,' + ((i+1) * legendBoxSize) + ')'; })
                .style("cursor", "pointer")
                .on("click", function(ty){ toggleSampleType(this, ty); });

          datasetTypes.append('rect')
              .attr('width', legendBoxSize)
              .attr('height', legendBoxSize)
              .style('fill', function(type) {return sampleTypeToColor[type];});

          datasetTypes.append('text')
              .attr('dy', legendBoxSize - 3)
              .attr('dx', 20)
              .text(function(type) {return type;});
      }// end renderSampleLegend()

    var mutationLegendTip = null;
    function renderMutationLegend(){
        var mutationRectWidth = 10,
            legendFontSize = 11,
            left = mutationRectWidth/2;

        var mutationLegend = selection.append('div')
            .append('a').text('Legend [+]')
            .attr('id','mutmtx-mutLegend-title')
            .style('font-weight', 'bold')
            .style('font-size', '14px')
            .style('margin-left', labelWidth + 'px')
            .on('click', function() {d3.event.preventDefault(); });

        mutationLegend.on('mouseover', function(d) {
          var titlePos = $('#mutmtx-mutLegend-title').position();
          mutationLegendTip = d3.select('body').append('div')
            .attr('id', 'mutmtx-mutLegend-tip')
            .style('background', '#fff')
            .style('border', '1px solid #ccc')
            .style('padding', '10px')
            .style('position', 'absolute')
            .style('top', (titlePos.top + 15) + 'px')
            .style('left', titlePos.left + 'px')
            .style('max-width', '500px');

          renderMutLegend();

          function renderMutLegend() {
            // Append a title
            mutationLegendTip.append("b").text("Aberrations");
            mutationLegendTip.append("br");

            // Add legend SVG
            var mutationLegendSVG = mutationLegendTip.append('svg')
                  .attr('id', 'mutation-legend')
                  .attr('height', mutationLegendHeight)
                  // .attr('width', 500)
            var mutationLegend = mutationLegendSVG.append('g').style('font-size', legendFontSize);

            function toggleMutationType(el, ty){
                var active = mutationTypeToInclude[ty],
                    opacity = active ? 0.5 : 1;

                d3.select(el).selectAll("*")
                  .style("fill-opacity", opacity)
                  .style("stroke-opacity", opacity);
                mutationTypeToInclude[ty] = !active;
                updateMutationMatrix();
            }

            // If the data contains multiple datasets, then mutations are
            //    colored by dataset, so the exclusive/co-occurring cells won't
            //    be shown. The dataset legend will float to the right of the
            //    mutation matrix.
            left = mutationRectWidth/2;
            if(!multiDataset) {
              // Exclusive ticks
              mutationLegend.append('rect')
                  .attr('x', left)
                  .attr('height', geneHeight)
                  .attr('width', mutationRectWidth)
                  .style('fill', exclusiveColor);

              mutationLegend.append('text')
                  .attr('x', mutationRectWidth + 10)
                  .attr('y', 3*geneHeight/4)
                  .style('fill', '#000')
                  .text('Exclusive');

              left += mutationRectWidth + 10 + 65;

              // Co-occurring ticks
              mutationLegend.append('rect')
                  .attr('x', left)
                  .attr('height', geneHeight)
                  .attr('width', mutationRectWidth)
                  .style('fill', coocurringColor);

              mutationLegend.append('text')
                  .attr('x', left + mutationRectWidth + 10)
                  .attr('y', 3*geneHeight/4)
                  .style('fill', '#000')
                  .text('Co-occurring');

              left += mutationRectWidth + 10 + 85;
            }

            // Add groups to hold each legend item
            if (mutationTypesPresent['snv']){
              var snvLegend = mutationLegend.append("g")
                .attr("transform", "translate(" + left + ",0)")
                .style("cursor", "pointer")
                .on("click", function(){ toggleMutationType(this, "snv"); });

              left += mutationRectWidth + 10 + 10 + 25;
            }

            if (mutationTypesPresent['inactive_snv']){
              var inactiveSNVLegend = mutationLegend.append("g")
                .attr("transform", "translate(" + left + ",0)")
                .style("cursor", "pointer")
                .on("click", function(){ toggleMutationType(this, "inactive_snv"); });

              left += mutationRectWidth + 10 + 75;
            }

            if (mutationTypesPresent['del']){
              var delLegend = mutationLegend.append("g")
                .attr("transform", "translate(" + left + ",0)")
                .style("cursor", "pointer")
                .on("click", function(){ toggleMutationType(this, "del"); });

              left += mutationRectWidth + 10 + 55;
            }

            if (mutationTypesPresent['amp']){
              var ampLegend = mutationLegend.append("g")
                .attr("transform", "translate(" + left + ",0)")
                .style("cursor", "pointer")
                .on("click", function(){ toggleMutationType(this, "amp"); });

              left += mutationRectWidth + 10 + 75;
            }

            if (mutationTypesPresent['fus']){
              var fusionLegend = mutationLegend.append("g")
                .attr("transform", "translate(" + left + ",0)")
                .style("cursor", "pointer")
                .on("click", function(){ toggleMutationType(this, "fus"); });

              left += mutationRectWidth + 10 + 220;
            }

            // SNVs (full ticks)
            if (mutationTypesPresent['snv']){
              snvLegend.append('rect')
                  .attr('height', geneHeight)
                  .attr('width', mutationRectWidth)
                  .style('fill', blockColorMedium);

              snvLegend.append('text')
                  .attr('dx', mutationRectWidth + 10)
                  .attr('dy', 3 * geneHeight / 4)
                  .style('fill', '#000')
                  .text('SNV');
            }

            // Inactivating SNVs (stripped full ticks)
            if (mutationTypesPresent['inactive_snv']){
              inactiveSNVLegend.append('rect')
                  .attr('height', geneHeight)
                  .attr('width', mutationRectWidth)
                  .style('fill', blockColorMedium);

              inactiveSNVLegend.append('rect')
                  .attr('y', 3 * geneHeight / 8)
                  .attr('height', geneHeight / 4)
                  .attr('width', mutationRectWidth)
                  .style('fill', '#000');

              inactiveSNVLegend.append('text')
                  .attr('dx', mutationRectWidth + 10)
                  .attr('dy', 3 * geneHeight / 4)
                  .style('fill', '#000')
                  .text('Inactivating');
            }

            // Deletions (down ticks)
            if (mutationTypesPresent['del']){
              delLegend.append('rect')
                  .attr('y', geneHeight / 2)
                  .attr('height', geneHeight / 2)
                  .attr('width', mutationRectWidth)
                  .style('fill', blockColorMedium);

              delLegend.append('text')
                  .attr('dx', mutationRectWidth + 5)
                  .attr('dy', 3 * geneHeight / 4)
                  .style('fill', '#000')
                  .text('Deletion');
            }

            // Amplifications (up ticks)
            if (mutationTypesPresent['amp']){
              ampLegend.append('rect')
                  .attr('height', geneHeight / 2)
                  .attr('width', mutationRectWidth)
                  .style('fill', blockColorMedium);

              ampLegend.append('text')
                  .attr('dx', mutationRectWidth + 10)
                  .attr('dy', 3*geneHeight / 4)
                  .style('fill', '#000')
                  .text('Amplification');
            }

            // Fusion legend
            if (mutationTypesPresent['fus']){
              fusionLegend.append('path')
                  .attr('d', d3.svg.symbol().type('triangle-up').size(30))
                  .attr('transform', 'translate(0,' + 3*geneHeight/8 + ')rotate(90)')
                  .style('stroke', bgColor)
                  .style('fill', blockColorMedium);

              fusionLegend.append('text')
                  .attr('dx', mutationRectWidth + 10)
                  .attr('dy', 3 * geneHeight / 4)
                  .style('fill', '#000')
                  .text('Fusion/Rearrangement/Splice Variant');
            }

            // Samples/box (the width/locations are set in renderMutationMatrix())
            mutationLegend.append('rect')
                .attr('x', left)
                .attr('id', 'sampleWidthRect')
                .attr('width', samplesPerCol * tickWidth - (2*sampleStroke))
                .attr('height', geneHeight)
                .style('fill', blockColorMedium);

            mutationLegend.append('text')
                .attr('id', 'sampleWidthText')
                .attr('x', left)
                .attr('y', 3 * geneHeight / 4)
                .attr("transform", "translate(" + (tickWidth + 5) + ",0)")
                .style('fill', '#000')
                .text(samplesPerCol == 1 ? '1 sample' : samplesPerCol + ' samples');

            mutationLegendSVG.attr("width", mutationLegend.node().getBBox().width)
          }

          // Add a sample annotations legend
          if (showSampleAnnotations){
            // Add a break and a title
            mutationLegendTip.append("br");
            mutationLegendTip.append("b").text("Sample annotations");
            mutationLegendTip.append("br");

            // Add a no data item
            if (annotationsIncludeNoData){
              var noData = mutationLegendTip.append("div")
                    .style('display', 'inline-block')
                    .style('padding', '5px')
                    .style("font-size", "12px")

              noData.append("div")
                  .style('background-color', "#333")
                  .style('display', 'inline-block')
                  .style('height', '12px')
                  .style('width', '12px')
                  .style('margin-right', '5px');

              noData.append("div").style('display', 'inline-block').text("No data");
            }

            // Create legend
            var categoryEls = mutationLegendTip.selectAll(".category")
                  .data(categories).enter()
                  .append("p")
                  .filter(function(c){ return c !== "Cancer type"; })
                  .style("margin", "0px")
                  .style("font-size", "12px")
                  .text(function(c){ return c; });

            var numericAnnotations = categoryEls
                  .filter(function(c){
                    if (annotationColors[c] == undefined) return false;
                    return annotationColors[c].type !== "ordinal";
                  })
                  .append("div")
                  .each(function(c, i){
                      var el = d3.select(this),
                          scale = annotationColors[c];

                      el.append("span")
                        .style("margin-right", "10px")
                        .text(d3.min(scale.domain()));

                      var gradientSVG = el.append("svg")
                            .style("width", 80)
                            .style("height", 15);

                      el.append("span")
                        .style("margin-left", "10px")
                        .text(d3.max(scale.domain()));

                      var gradient = gradientSVG.append("svg:defs")
                            .append("svg:linearGradient")
                            .attr("id", "gradient" + i)
                            .attr("x1", "0%")
                            .attr("y1", "0%")
                            .attr("x2", "100%")
                            .attr("y2", "0%");

                      gradient.append("svg:stop")
                        .attr("offset", "0%")
                        .attr("stop-color", scale(d3.min(scale.domain())))
                        .attr("stop-opacity", 1);

                      gradient.append("svg:stop")
                        .attr("offset", "100%")
                        .attr("stop-color", scale(d3.max(scale.domain())))
                        .attr("stop-opacity", 1);


                      gradientSVG.append('rect')
                        .attr('width', 80)
                        .attr('height', 15)
                        .style('fill','url(#gradient' + i + ')');

                  });

            categoryEls.append("br")
            var categoricalAnnotations = categoryEls
                  .filter(function(c){
                    if (annotationColors[c] == undefined) return false;
                    return annotationColors[c].type === "ordinal";
                  })
                  .selectAll(".annotation")
                  .data(function(c){ return categorySets[c]; }).enter()
                  .append("div")
                  .style('display', 'inline-block')
                  .style('padding', '5px');

            categoricalAnnotations.append("div")
                .style('background-color', function(d){ return annotationColors[d.cat](d.ann); })
                .style('display', 'inline-block')
                .style('height', '12px')
                .style('width', '12px')
                .style('margin-right', '5px');

            categoricalAnnotations.append("div")
                .style('display', 'inline-block')
                .text(function(d){ return d.ann; });
          }
        });

        mutationLegend.on('mouseout', function() {
          d3.select('#mutation-legend').remove();
          mutationLegendTip.remove();
          mutationLegendTip = null;
        });
      }// end renderMutationLegend()


      function renderSortingMenu() {
        var sampleSort = selection.append('div')
            .attr('id', 'sample-sorting-interface')
            .style('margin-left', labelWidth + 'px')
            .style('font-size', 12 + 'px');

        var interfaceLink = sampleSort.append('a')
            .style('font-weight', 'bold')
            .style("font-size", "14px")
            .text('Sort mutation matrix by: ')
            .on('click', function() {
              // TODO enable hiding/showing menu
              // d3.select('ul#sample-sort-list').style('display', 'block');
              if($('ul#sample-sort-list').is(':visible')) {
                $('ul#sample-sort-list').slideUp();
                $('span#interface-status').html("&uarr;")
              } else {
                $('ul#sample-sort-list').slideDown();
                $('span#interface-status').html("&darr;")
              }
            });

        interfaceLink.append('span')
            .attr('id', 'interface-status')
            .style("cursor", "pointer")
            .html("&uarr;")

        var sortFnsContainer = sampleSort.append('ul')
            .attr('id', 'sample-sort-list')
            .style('padding-left', '10px')
            .style('display', 'none');

        // reorder uses the given sample sort parameters to resort the samples
        //    and then moves them to their new locations
        function reorder(sampleSortOrder) {
          // Resort the samples and update the index
          var sortedSampleIndices = sortSamples(sampleSortOrder, sortedGenes, sampleToGeneIndex, sampleToExclusivity);
          for (var i = 0; i < numMutatedSamples; i++) {
            sampleToIndex[uniqueSamples[sortedSampleIndices[i]].snid] = i;
          }

          // Perform the transition: move elements in the order of where they
          //    will end up on the x-axis
          matrix.transition().duration(animationSpeed)
              .delay(function(d){ return x(sampleToIndex[d.snid]); })
              .attr('transform', function(d) { return 'translate(' + x(sampleToIndex[d.snid]) + ',0)'; });

          // Update the sample sorting interface (defined below)
          sampleSorterInterface();
        }

        // Shift items in the sample sort order list based on whether the user
        //    presses up/down. Then calls reorder to update the mutation matrix
        function updateSampleOrder(n, move) {
          var newSampleSortOrder = sampleSortOrder,
              i = sampleSortOrder.indexOf(n),
              j = i - move;

          if (j != -1 && j < sampleSortOrder.length) {
            newSampleSortOrder[i] = newSampleSortOrder[j];
            newSampleSortOrder[j] = n;
          }
          reorder(newSampleSortOrder);
        }


        // Lists the sample sorting functions in the current order being used,
        //    along with arrows so the user can modify the order
        function sampleSorterInterface() {
          // Remove the old sample sorting interface
          sortFnsContainer.selectAll('*').remove();

          // Append a list of the way the mutation matrix is sorted
          var sortFns = sortFnsContainer.selectAll('.sort-fn')
              .data(sampleSortOrder).enter()
              .append('li')
                .style('list-style-type', 'none')
                .style('margin-bottom', '5px');

          // Down and up arrows to chagne the z_index of the different
          //    sorting operators
          sortFns.append('span')
              .style("cursor", "pointer")
              .html('&darr;')
              .on("mouseover", function(){ d3.select(this).style("color", "red"); })
              .on("mouseout", function(){ d3.select(this).style("color", "black"); })
              .on('click', function(d, i) { updateSampleOrder(d, -1); });

          sortFns.append('span')
              .style("cursor", "pointer")
              .html('&uarr;')
              .on("mouseover", function(){ d3.select(this).style("color", "red"); })
              .on("mouseout", function(){ d3.select(this).style("color", "black"); })
              .on('click', function(d, i) { updateSampleOrder(d, 1); });

          // Add a short description of what each sort parameter is
          sortFns.append('span').text(function(d){
            var name = sortFnName[d];
            return ' ' + sortFnName[d];
          });
        }
        sampleSorterInterface();
      } // End renderSortingMenu()

      // Render the mutation matrix and then reset its height to remove whitespace
      renderMutationMatrix();
      svg.attr('height', svg.node().getBBox().height);

      if (showCoverage) {
        renderCoverage();
      }
      if (showSampleLegend) {
        renderSampleLegend();
      }
      if (showMutationLegend) {
        renderMutationLegend();
      }
      if (showSortingMenu) {
        renderSortingMenu();
      }

    });
  }

  chart.addCoverage = function() {
    showCoverage = true;
    return chart;
  }

  chart.addSampleLegend = function () {
    showSampleLegend = true;
    return chart;
  }

  chart.addMutationLegend = function () {
    showMutationLegend = true;
    return chart;
  }

  chart.addSortingMenu = function () {
    showSortingMenu = true;
    return chart;
  }

  chart.addSampleAnnotations = function(data) {
    annotationData = data || {};
    // only show sample annotations if the data exists
    if (annotationData.sampleToAnnotations) showSampleAnnotations = true;
    return chart;
  }

  chart.showDuplicates = function () {
    showDuplicates = true;
    return chart;
  }

  chart.width = function(_) {
    if (!arguments.length) return width;
    fullWidth = _;
    return chart;
  };

  chart.height = function(_) {
    if (!arguments.length) return height;
    fullHeight = _;
    return chart;
  };

  chart.filterDatasets = function(datasetToInclude) {
    Object.keys(datasetToInclude).forEach(function(d){
      sampleTypeToInclude[d] = datasetToInclude[d];
    });
    updateMutationMatrix();
  }

  chart.addTooltips = function(annotater){
    showTooltips = true;
    annotate = annotater;
    if (ticks && tip){
      tip.html(annotater);
    }
    return chart;
  }

chart.addOnClick = function (fn) {
    addOnClick = true;
    onclickFunction = fn;
    return chart;
  }


  return chart;
}
</script>
